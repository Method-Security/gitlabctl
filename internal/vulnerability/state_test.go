package vulnerability_test

import (
	"reflect"
	"testing"

	"github.com/Method-Security/gitlabctl/internal/vulnerability"
)

func TestToState(t *testing.T) {
	tests := []struct {
		name  string
		state string
		want  vulnerability.State
	}{
		{
			name:  "Test State Detected",
			state: "detected",
			want:  vulnerability.StateDetected,
		},
		{
			name:  "Test State Resolved",
			state: "resolved",
			want:  vulnerability.StateResolved,
		},
		{
			name:  "Test State Resolved Caps",
			state: "Resolved",
			want:  vulnerability.StateResolved,
		},
		{
			name:  "Test State Dismissed",
			state: "dismissed",
			want:  vulnerability.StateDismissed,
		},
		{
			name:  "Test Unknown State",
			state: "unknown",
			want:  vulnerability.StateDetected,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := vulnerability.ToState(tt.state)
			if got != tt.want {
				t.Errorf("ToState(%s) = %s, want %s", tt.state, got, tt.want)
			}
		})
	}
}

func TestToStates(t *testing.T) {
	tests := []struct {
		name   string
		states []string
		want   []vulnerability.State
	}{
		{
			name:   "Test Empty States",
			states: []string{},
			want:   []vulnerability.State{},
		},
		{
			name:   "Test Single State",
			states: []string{"detected"},
			want:   []vulnerability.State{vulnerability.StateDetected},
		},
		{
			name:   "Test Multiple States",
			states: []string{"detected", "resolved", "dismissed"},
			want: []vulnerability.State{
				vulnerability.StateDetected,
				vulnerability.StateResolved,
				vulnerability.StateDismissed,
			},
		},
		{
			name:   "Test Unknown State",
			states: []string{"unknown"},
			want:   []vulnerability.State{vulnerability.StateDetected},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			got := vulnerability.ToStates(tt.states)
			if !reflect.DeepEqual(got, tt.want) {
				t.Errorf("ToStates(%v) = %v, want %v", tt.states, got, tt.want)
			}
		})
	}
}

func TestContainsState(t *testing.T) {
	tests := []struct {
		name        string
		state       vulnerability.State
		states      []vulnerability.State
		wantContain bool
	}{
		{
			name:        "Test Contains Detected",
			state:       vulnerability.StateDetected,
			states:      []vulnerability.State{vulnerability.StateDetected, vulnerability.StateResolved},
			wantContain: true,
		},
		{
			name:        "Test Contains Resolved",
			state:       vulnerability.StateResolved,
			states:      []vulnerability.State{vulnerability.StateDetected, vulnerability.StateResolved},
			wantContain: true,
		},
		{
			name:        "Test Contains Dismissed",
			state:       vulnerability.StateDismissed,
			states:      []vulnerability.State{vulnerability.StateDetected, vulnerability.StateResolved},
			wantContain: false,
		},
		{
			name:        "Test Contains Empty States",
			state:       vulnerability.StateDetected,
			states:      []vulnerability.State{},
			wantContain: false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			gotContain := vulnerability.ContainsState(tt.state, tt.states)
			if gotContain != tt.wantContain {
				t.Errorf("ContainsState(%s, %v) = %v, want %v", tt.state, tt.states, gotContain, tt.wantContain)
			}
		})
	}
}
